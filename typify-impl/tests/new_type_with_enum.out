#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Everything {
    #[doc = "name"]
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enum_property: Option<EverythingEnumProperty>,
}
#[doc = "name"]
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
pub struct EverythingEnumProperty(EverythingEnumPropertyInner);
impl std::ops::Deref for EverythingEnumProperty {
    type Target = EverythingEnumPropertyInner;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl std::convert::TryFrom<EverythingEnumPropertyInner> for EverythingEnumProperty {
    type Error = &'static str;
    fn try_from(value: EverythingEnumPropertyInner) -> Result<Self, Self::Error> {
        if ![
            EverythingEnumPropertyInner("first".to_string()),
            EverythingEnumPropertyInner("second".to_string()),
        ]
        .contains(&value)
        {
            Err("invalid value")
        } else {
            Ok(Self(value))
        }
    }
}
#[doc = "name"]
#[derive(Clone, Debug, Serialize)]
pub struct EverythingEnumPropertyInner(String);
impl std::ops::Deref for EverythingEnumPropertyInner {
    type Target = String;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl std::convert::TryFrom<&str> for EverythingEnumPropertyInner {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        if value.len() > 32usize {
            return Err("longer than 32 characters");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&String> for EverythingEnumPropertyInner {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, Self::Error> {
        Self::try_from(value.as_str())
    }
}
impl std::convert::TryFrom<String> for EverythingEnumPropertyInner {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, Self::Error> {
        Self::try_from(value.as_str())
    }
}
impl<'de> serde::Deserialize<'de> for EverythingEnumPropertyInner {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Self::try_from(String::deserialize(deserializer)?)
            .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
